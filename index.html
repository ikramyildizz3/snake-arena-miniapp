<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Snake Arena – Classic+</title>
  <style>
    * {
      box-sizing: border-box;
      margin: 0;
      padding: 0;
    }

    body {
      font-family: system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      background: radial-gradient(circle at top, #141b25 0, #05070b 55%, #020308 100%);
      color: #e9f1ff;
      min-height: 100vh;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .app-shell {
      width: 100%;
      max-width: 900px;
      padding: 10px 10px 14px;
    }

    .top-row {
      display: flex;
      gap: 10px;
      align-items: stretch;
    }

    .hud-card {
      flex: 1.1;
      background: rgba(6, 12, 18, 0.95);
      border-radius: 14px;
      border: 1px solid rgba(124, 255, 151, 0.4);
      padding: 8px 10px;
      display: grid;
      grid-template-columns: repeat(6, minmax(0, 1fr));
      gap: 4px;
      font-size: 11px;
    }

    .hud-item {
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      padding: 2px 3px;
      border-radius: 8px;
      background: radial-gradient(circle at top, rgba(22, 40, 30, 0.9), rgba(5, 10, 8, 0.9));
    }

    .hud-label {
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      opacity: 0.7;
    }

    .hud-value {
      font-weight: 700;
      font-size: 14px;
    }

    .mode-pill {
      justify-self: flex-end;
      align-self: center;
      padding: 4px 9px;
      border-radius: 999px;
      border: 1px solid rgba(255, 255, 255, 0.12);
      background: linear-gradient(135deg, #0d1419, #111b24);
      font-size: 10px;
      text-align: center;
      min-width: 70px;
    }

    .mode-pill span {
      display: block;
      font-size: 8px;
      text-transform: uppercase;
      opacity: 0.7;
    }

    .game-frame-wrapper {
      flex: 1.2;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .game-frame {
      position: relative;
      background: radial-gradient(circle at top, #07100b 0, #020503 55%, #000000 100%);
      border-radius: 18px;
      padding: 10px;
      border: 2px solid rgba(124, 255, 151, 0.5);
      box-shadow: 0 0 0 1px rgba(0, 0, 0, 0.8), 0 18px 40px rgba(0, 0, 0, 0.8);
      width: 100%;
      max-width: 520px;
      aspect-ratio: 1 / 1;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: hidden;
    }

    canvas {
      width: 100%;
      height: 100%;
      image-rendering: pixelated;
      display: block;
    }

    .bottom-row {
      margin-top: 10px;
      display: flex;
      gap: 10px;
      align-items: stretch;
    }

    .help-card {
      flex: 1.1;
      background: rgba(8, 11, 16, 0.96);
      border-radius: 14px;
      border: 1px solid rgba(255, 255, 255, 0.08);
      padding: 8px 10px;
      font-size: 11px;
      line-height: 1.45;
    }

    .help-card strong {
      color: #7cff97;
    }

    .desktop-actions {
      flex: 1;
      display: flex;
      justify-content: flex-end;
      align-items: center;
      gap: 10px;
    }

    .pill-btn {
      border-radius: 999px;
      border: 1px solid rgba(124, 255, 151, 0.35);
      background: radial-gradient(circle at top, #0e1d14, #030806);
      color: #e9f1ff;
      font-size: 11px;
      padding: 7px 14px;
      display: inline-flex;
      align-items: center;
      gap: 6px;
      cursor: pointer;
      user-select: none;
      white-space: nowrap;
    }

    .pill-btn span.small {
      font-size: 9px;
      opacity: 0.7;
    }

    .pill-btn:active {
      transform: translateY(1px) scale(0.98);
    }

    .pill-btn.dim {
      opacity: 0.4;
      border-style: dashed;
      cursor: default;
    }

    /* Mobile controls */
    .mobile-controls {
      margin-top: 12px;
      display: none;
      gap: 16px;
      align-items: center;
      justify-content: space-between;
    }

    .dpad {
      width: 140px;
      height: 140px;
      position: relative;
      display: grid;
      place-items: center;
    }

    .dpad-btn {
      position: absolute;
      width: 54px;
      height: 54px;
      border-radius: 18px;
      border: 1px solid rgba(124, 255, 151, 0.4);
      background: radial-gradient(circle at top, #111b16, #050806);
      color: #e9f1ff;
      font-size: 18px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      user-select: none;
    }

    .dpad-btn:active {
      transform: translateY(1px) scale(0.95);
    }

    .dpad-btn.up { top: 0; left: 50%; transform: translate(-50%, 0); }
    .dpad-btn.down { bottom: 0; left: 50%; transform: translate(-50%, 0); }
    .dpad-btn.left { left: 0; top: 50%; transform: translate(0, -50%); }
    .dpad-btn.right { right: 0; top: 50%; transform: translate(0, -50%); }

    .dpad-center {
      width: 60px;
      height: 60px;
      border-radius: 20px;
      border: 1px solid rgba(124, 255, 151, 0.35);
      background: radial-gradient(circle at top, #0e1b14, #020403);
      opacity: 0.8;
    }

    .mobile-actions {
      flex: 1;
      display: flex;
      justify-content: flex-end;
      gap: 10px;
    }

    .mobile-main-btn {
      flex: 1;
      min-width: 0;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(124, 255, 151, 0.4);
      background: radial-gradient(circle at top, #0e1b14, #050609);
      color: #e9f1ff;
      font-size: 12px;
      font-weight: 600;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      gap: 2px;
      user-select: none;
    }

    .mobile-main-btn span.small {
      font-size: 9px;
      opacity: 0.7;
    }

    .mobile-main-btn:active {
      transform: translateY(1px) scale(0.97);
    }

    .mobile-main-btn.dim { opacity: 0.4; border-style: dashed; }

    .badge-echo {
      color: #7cd3ff;
      font-size: 10px;
    }

    .badge-paused {
      color: #ffb86b;
      font-size: 10px;
    }

    .toast {
      position: fixed;
      left: 50%;
      bottom: 18px;
      transform: translateX(-50%);
      padding: 6px 12px;
      border-radius: 999px;
      background: rgba(0, 0, 0, 0.85);
      color: #e9f1ff;
      font-size: 11px;
      border: 1px solid rgba(255, 255, 255, 0.15);
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.25s ease;
      z-index: 40;
    }

    .toast.visible { opacity: 1; }

    @media (max-width: 780px) {
      .top-row {
        flex-direction: column;
      }

      .bottom-row {
        flex-direction: column;
      }

      .desktop-actions {
        justify-content: space-between;
      }

      .mobile-controls {
        display: flex;
      }
    }
  </style>
</head>
<body>
  <div class="app-shell">
    <div class="top-row">
      <div class="hud-card">
        <div class="hud-item">
          <div class="hud-label">Skor</div>
          <div class="hud-value" id="hud-score">0</div>
        </div>
        <div class="hud-item">
          <div class="hud-label">Best</div>
          <div class="hud-value" id="hud-best">0</div>
        </div>
        <div class="hud-item">
          <div class="hud-label">Uzunluk</div>
          <div class="hud-value" id="hud-length">5</div>
        </div>
        <div class="hud-item">
          <div class="hud-label">Hız</div>
          <div class="hud-value" id="hud-speed">x1.0</div>
        </div>
        <div class="hud-item">
          <div class="hud-label">Echo</div>
          <div class="hud-value" id="hud-echo">3</div>
        </div>
        <div class="hud-item">
          <div class="hud-label">Can</div>
          <div class="hud-value" id="hud-lives">3</div>
        </div>
        <div class="hud-item">
          <div class="hud-label">Bölüm</div>
          <div class="hud-value" id="hud-level">1</div>
        </div>
        <div class="mode-pill">
          CASUAL
          <span>yavaş + öğrenme modu</span>
        </div>
      </div>

      <div class="game-frame-wrapper">
        <div class="game-frame">
          <canvas id="game"></canvas>
        </div>
      </div>
    </div>

    <div class="bottom-row">
      <div class="help-card">
        <strong>Kontroller</strong><br />
        PC: Yön için WASD veya ok tuşları · <strong>Space</strong> = Echo (geri sar) · <strong>P</strong> = Dur / devam.<br />
        Mobil: Aşağıdaki yön tuşlarını kullan · ECHO ve DUR butonları sağda.
        <br /><br />
        Echo: son birkaç hamleyi kaydedip seni geriye alır, zor durumdan kurtarır. Mavi orb yersen Echo +1 (maks. 3).<br />
        Bölüm atlamak için yeterince yem topla; her bölümde duvar düzeni zorlaşır.
      </div>

      <div class="desktop-actions">
        <button class="pill-btn" id="btn-echo-desktop">
          ECHO
          <span class="small">Space</span>
        </button>
        <button class="pill-btn" id="btn-pause-desktop">
          DUR
          <span class="small">P</span>
        </button>
      </div>
    </div>

    <div class="mobile-controls">
      <div class="dpad">
        <div class="dpad-center"></div>
        <button class="dpad-btn up" data-dir="up">▲</button>
        <button class="dpad-btn down" data-dir="down">▼</button>
        <button class="dpad-btn left" data-dir="left">◀</button>
        <button class="dpad-btn right" data-dir="right">▶</button>
      </div>
      <div class="mobile-actions">
        <button class="mobile-main-btn" id="btn-echo-mobile">
          ECHO
          <span class="badge-echo" id="badge-echo-mobile">3 hak</span>
          <span class="small">geri sar</span>
        </button>
        <button class="mobile-main-btn" id="btn-pause-mobile">
          DUR
          <span class="badge-paused" id="badge-pause-mobile">oyunda</span>
          <span class="small">duraklat</span>
        </button>
      </div>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <script>
    // ----- Canvas ve grid ayarları -----
    const canvas = document.getElementById("game");
    const ctx = canvas.getContext("2d");

    const GRID_COLS = 30;
    const GRID_ROWS = 30;
    let cellSize = 16; // hesaplanacak

    function resizeCanvas() {
      const frame = canvas.parentElement.getBoundingClientRect();
      const size = Math.min(frame.width, frame.height);
      const dpr = window.devicePixelRatio || 1;
      canvas.width = size * dpr;
      canvas.height = size * dpr;
      ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
      cellSize = size / GRID_COLS;
      draw();
    }

    window.addEventListener("resize", resizeCanvas);

    // ----- HUD helper -----
    const hudScore = document.getElementById("hud-score");
    const hudBest = document.getElementById("hud-best");
    const hudLength = document.getElementById("hud-length");
    const hudSpeed = document.getElementById("hud-speed");
    const hudEcho = document.getElementById("hud-echo");
    const hudLives = document.getElementById("hud-lives");
    const hudLevel = document.getElementById("hud-level");

    const echoBadgeMobile = document.getElementById("badge-echo-mobile");
    const pauseBadgeMobile = document.getElementById("badge-pause-mobile");

    const toastEl = document.getElementById("toast");
    let toastTimeout = null;

    function showToast(text) {
      if (!toastEl) return;
      toastEl.textContent = text;
      toastEl.classList.add("visible");
      if (toastTimeout) clearTimeout(toastTimeout);
      toastTimeout = setTimeout(() => toastEl.classList.remove("visible"), 1700);
    }

    // ----- Oyun state'i -----
    let score = 0;
    let bestScore = 0;
    let lives = 3;
    let levelIndex = 0; // 0 tabanlı

    const SPEEDS = [140, 115, 95, 80]; // ms per step
    let tickInterval = SPEEDS[0];
    let isPaused = false;
    let gameOver = false;

    let loopId = null; // setInterval id

    const directions = {
      up: { x: 0, y: -1 },
      down: { x: 0, y: 1 },
      left: { x: -1, y: 0 },
      right: { x: 1, y: 0 },
    };

    let currentDir = directions.right;
    let nextDir = directions.right;

    let snake = [];
    let snakeHistory = []; // echo için pozisyon kayıtları
    const MAX_HISTORY = 40;

    let food = null;
    let echoOrb = null;

    let echoCharges = 3;

    const LEVELS = [
      {
        name: "Bölüm 1",
        walls: [],
        neededFood: 6,
      },
      {
        name: "Bölüm 2",
        walls: generateRingWalls(4),
        neededFood: 7,
      },
      {
        name: "Bölüm 3",
        walls: generateCrossWalls(),
        neededFood: 8,
      },
      {
        name: "Bölüm 4",
        walls: generateMazeWalls(),
        neededFood: 9,
      },
    ];

    let foodEatenThisLevel = 0;

    function generateRingWalls(padding) {
      const tiles = [];
      const minX = padding;
      const maxX = GRID_COLS - padding - 1;
      const minY = padding;
      const maxY = GRID_ROWS - padding - 1;
      for (let x = minX; x <= maxX; x++) {
        tiles.push({ x, y: minY });
        tiles.push({ x, y: maxY });
      }
      for (let y = minY; y <= maxY; y++) {
        tiles.push({ x: minX, y });
        tiles.push({ x: maxX, y });
      }
      return tiles;
    }

    function generateCrossWalls() {
      const tiles = [];
      const cx = Math.floor(GRID_COLS / 2);
      const cy = Math.floor(GRID_ROWS / 2);
      for (let x = 4; x < GRID_COLS - 4; x++) {
        if (Math.abs(x - cx) < 3) continue;
        tiles.push({ x, y: cy });
      }
      for (let y = 4; y < GRID_ROWS - 4; y++) {
        if (Math.abs(y - cy) < 3) continue;
        tiles.push({ x: cx, y });
      }
      return tiles;
    }

    function generateMazeWalls() {
      const tiles = [];
      for (let x = 3; x < GRID_COLS - 3; x++) {
        if (x % 2 === 0) tiles.push({ x, y: 6 });
        if (x % 3 === 0) tiles.push({ x, y: GRID_ROWS - 7 });
      }
      for (let y = 8; y < GRID_ROWS - 8; y++) {
        if (y % 2 === 1) tiles.push({ x: 6, y });
        if (y % 3 === 1) tiles.push({ x: GRID_COLS - 7, y });
      }
      return tiles;
    }

    function resetSnake(centerOnly = false) {
      const cx = Math.floor(GRID_COLS / 2);
      const cy = Math.floor(GRID_ROWS / 2);
      snake = [];
      for (let i = 0; i < 5; i++) {
        snake.unshift({ x: cx - i, y: cy });
      }
      currentDir = directions.right;
      nextDir = directions.right;
      snakeHistory = [];
      if (!centerOnly) {
        foodEatenThisLevel = 0;
      }
    }

    function placeRandomTile(avoid = []) {
      while (true) {
        const x = Math.floor(Math.random() * GRID_COLS);
        const y = Math.floor(Math.random() * GRID_ROWS);
        const collides = avoid.some((p) => p.x === x && p.y === y);
        if (!collides) return { x, y };
      }
    }

    function spawnFood() {
      const walls = LEVELS[levelIndex].walls;
      const avoid = [...snake, ...walls];
      food = placeRandomTile(avoid);
      // %20 ihtimalle echo orb spawnla ama çakışmasın
      if (Math.random() < 0.2) {
        echoOrb = placeRandomTile([...avoid, food]);
      } else {
        echoOrb = null;
      }
    }

    function startLoop() {
      if (loopId) clearInterval(loopId);
      loopId = setInterval(() => {
        if (!gameOver) {
          step();
          draw();
        }
      }, tickInterval);
    }

    function startGame() {
      score = 0;
      lives = 3;
      levelIndex = 0;
      tickInterval = SPEEDS[0];
      gameOver = false;
      isPaused = false;
      echoCharges = 3;
      foodEatenThisLevel = 0;
      resetSnake();
      spawnFood();
      updateHud();
      draw();
      startLoop();
      showToast("Hazırsın – iyi oyunlar!");
    }

    function loseLife() {
      lives--;
      if (lives <= 0) {
        gameOver = true;
        lives = 0;
        updateHud();
        if (loopId) clearInterval(loopId);
        showToast("Game over – R ile yeniden başla");
        return;
      }
      resetSnake(true);
      spawnFood();
      updateHud();
      showToast(`Çarpıştın! Kalan can: ${lives}`);
    }

    function nextLevel() {
      if (levelIndex < LEVELS.length - 1) {
        levelIndex++;
        tickInterval = SPEEDS[Math.min(levelIndex, SPEEDS.length - 1)];
        resetSnake();
        spawnFood();
        showToast(`Bölüm ${levelIndex + 1}! Duvarlar değişti`);
      } else {
        resetSnake();
        spawnFood();
        showToast("Arena ustası! Aynı bölümde devam");
      }
      updateHud();
      draw();
      startLoop();
    }

    function updateHud() {
      hudScore.textContent = score;
      hudBest.textContent = bestScore;
      hudLength.textContent = snake.length;
      const speedMult = (SPEEDS[0] / tickInterval).toFixed(1);
      hudSpeed.textContent = `x${speedMult}`;
      hudEcho.textContent = echoCharges;
      hudLives.textContent = lives;
      hudLevel.textContent = levelIndex + 1;
      if (echoBadgeMobile) echoBadgeMobile.textContent = `${echoCharges} hak`;
      if (pauseBadgeMobile) pauseBadgeMobile.textContent = isPaused ? "duraklatıldı" : "oyunda";
    }

    function changeDirection(dirKey) {
      if (gameOver) return;
      const dir = directions[dirKey];
      if (!dir) return;
      // ters yöne dönüşü engelle
      if (dir.x === -currentDir.x && dir.y === -currentDir.y) return;
      nextDir = dir;
    }

    function handleEcho() {
      if (gameOver) return;
      if (echoCharges <= 0) {
        showToast("Echo hakkın yok");
        return;
      }
      if (snakeHistory.length < 10) {
        showToast("Echo için yeterli kayıt yok");
        return;
      }
      const snapshot = snakeHistory[Math.max(0, snakeHistory.length - 15)];
      snake = snapshot.snake.map((p) => ({ x: p.x, y: p.y }));
      currentDir = { ...snapshot.dir };
      nextDir = { ...snapshot.dir };
      echoCharges--;
      updateHud();
      showToast("Echo! Zamanı geri sardın");
    }

    function togglePause() {
      if (gameOver) return;
      isPaused = !isPaused;
      if (pauseBadgeMobile) pauseBadgeMobile.textContent = isPaused ? "duraklatıldı" : "oyunda";
      showToast(isPaused ? "Oyun durduruldu" : "Devam");
    }

    function step() {
      if (gameOver || isPaused) return;

      // history kaydet
      snakeHistory.push({
        snake: snake.map((p) => ({ x: p.x, y: p.y })),
        dir: { ...currentDir },
      });
      if (snakeHistory.length > MAX_HISTORY) snakeHistory.shift();

      currentDir = nextDir;
      const head = snake[0];
      const newHead = { x: head.x + currentDir.x, y: head.y + currentDir.y };

      // sınır kontrolü
      if (
        newHead.x < 0 ||
        newHead.x >= GRID_COLS ||
        newHead.y < 0 ||
        newHead.y >= GRID_ROWS
      ) {
        loseLife();
        return;
      }

      // duvar kontrolü
      const walls = LEVELS[levelIndex].walls;
      if (walls.some((w) => w.x === newHead.x && w.y === newHead.y)) {
        loseLife();
        return;
      }

      // kendine çarpma
      if (snake.some((p) => p.x === newHead.x && p.y === newHead.y)) {
        loseLife();
        return;
      }

      snake.unshift(newHead);

      // echo orb
      if (echoOrb && newHead.x === echoOrb.x && newHead.y === echoOrb.y) {
        if (echoCharges < 3) echoCharges++;
        echoOrb = null;
        showToast("Echo +1");
      }

      // yemek
      if (food && newHead.x === food.x && newHead.y === food.y) {
        score += 10 + levelIndex * 3;
        if (score > bestScore) bestScore = score;
        foodEatenThisLevel++;
        spawnFood();
        if (foodEatenThisLevel >= LEVELS[levelIndex].neededFood) {
          nextLevel();
        }
      } else {
        snake.pop();
      }

      updateHud();
    }

    // ----- Çizim -----
    function clear() {
      ctx.fillStyle = "#020604";
      ctx.fillRect(0, 0, canvas.width, canvas.height);
    }

    function drawGrid() {
      ctx.strokeStyle = "rgba(40, 80, 50, 0.35)";
      ctx.lineWidth = 1;
      for (let x = 0; x <= GRID_COLS; x++) {
        ctx.beginPath();
        ctx.moveTo(x * cellSize, 0);
        ctx.lineTo(x * cellSize, GRID_ROWS * cellSize);
        ctx.stroke();
      }
      for (let y = 0; y <= GRID_ROWS; y++) {
        ctx.beginPath();
        ctx.moveTo(0, y * cellSize);
        ctx.lineTo(GRID_COLS * cellSize, y * cellSize);
        ctx.stroke();
      }
    }

    function drawWalls() {
      const walls = LEVELS[levelIndex].walls;
      ctx.fillStyle = "#0b2012";
      ctx.strokeStyle = "rgba(124,255,151,0.7)";
      ctx.lineWidth = 2;
      for (const w of walls) {
        const x = w.x * cellSize;
        const y = w.y * cellSize;
        ctx.fillRect(x, y, cellSize, cellSize);
        ctx.strokeRect(x + 1, y + 1, cellSize - 2, cellSize - 2);
      }
    }

    function drawFood() {
      if (!food) return;
      const x = (food.x + 0.5) * cellSize;
      const y = (food.y + 0.5) * cellSize;
      const r = cellSize * 0.26;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      const grad = ctx.createRadialGradient(x - r / 3, y - r / 3, r * 0.2, x, y, r);
      grad.addColorStop(0, "#ffe9a0");
      grad.addColorStop(1, "#ffb347");
      ctx.fillStyle = grad;
      ctx.fill();
    }

    function drawEchoOrb() {
      if (!echoOrb) return;
      const x = (echoOrb.x + 0.5) * cellSize;
      const y = (echoOrb.y + 0.5) * cellSize;
      const r = cellSize * 0.23;
      ctx.beginPath();
      ctx.arc(x, y, r, 0, Math.PI * 2);
      const grad = ctx.createRadialGradient(x - r / 3, y - r / 3, r * 0.2, x, y, r);
      grad.addColorStop(0, "#c5f1ff");
      grad.addColorStop(1, "#3cb4ff");
      ctx.fillStyle = grad;
      ctx.fill();
      ctx.beginPath();
      ctx.arc(x, y, r * 1.4, 0, Math.PI * 2);
      ctx.strokeStyle = "rgba(124,211,255,0.5)";
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    function drawSnake() {
      if (!snake.length) return;
      // gövde
      for (let i = snake.length - 1; i >= 0; i--) {
        const seg = snake[i];
        const t = i / snake.length;
        const x = seg.x * cellSize;
        const y = seg.y * cellSize;
        const r = cellSize * (0.58 - t * 0.18);
        const cx = x + cellSize / 2;
        const cy = y + cellSize / 2;
        const grad = ctx.createRadialGradient(cx - r / 2, cy - r / 2, r * 0.2, cx, cy, r);
        grad.addColorStop(0, `rgba(180,255,190,${0.9 - t * 0.5})`);
        grad.addColorStop(1, `rgba(60,180,95,${0.95 - t * 0.65})`);
        ctx.beginPath();
        ctx.arc(cx, cy, r, 0, Math.PI * 2);
        ctx.fillStyle = grad;
        ctx.fill();
      }

      // kafa
      const head = snake[0];
      const hx = head.x * cellSize + cellSize / 2;
      const hy = head.y * cellSize + cellSize / 2;
      const hr = cellSize * 0.7;
      ctx.beginPath();
      ctx.arc(hx, hy, hr * 0.9, 0, Math.PI * 2);
      const headGrad = ctx.createRadialGradient(hx - hr / 3, hy - hr / 3, hr * 0.2, hx, hy, hr);
      headGrad.addColorStop(0, "#d9ffe4");
      headGrad.addColorStop(1, "#6dff94");
      ctx.fillStyle = headGrad;
      ctx.fill();

      // yön için açı
      const angle = Math.atan2(currentDir.y, currentDir.x);
      ctx.save();
      ctx.translate(hx, hy);
      ctx.rotate(angle);

      // gözler
      const eyeOffsetX = hr * 0.3;
      const eyeOffsetY = hr * 0.35;
      const eyeR = hr * 0.2;
      ctx.fillStyle = "#ffffff";
      ctx.beginPath();
      ctx.arc(eyeOffsetX, -eyeOffsetY, eyeR, 0, Math.PI * 2);
      ctx.arc(eyeOffsetX, eyeOffsetY, eyeR, 0, Math.PI * 2);
      ctx.fill();

      ctx.fillStyle = "#04120b";
      ctx.beginPath();
      ctx.arc(eyeOffsetX + eyeR * 0.2, -eyeOffsetY, eyeR * 0.45, 0, Math.PI * 2);
      ctx.arc(eyeOffsetX + eyeR * 0.2, eyeOffsetY, eyeR * 0.45, 0, Math.PI * 2);
      ctx.fill();

      // dil
      ctx.strokeStyle = "#ff6b6b";
      ctx.lineWidth = 2;
      ctx.beginPath();
      ctx.moveTo(hr * 0.9, 0);
      ctx.lineTo(hr * 1.25, 0);
      ctx.stroke();

      ctx.restore();
    }

    function draw() {
      clear();
      drawGrid();
      drawWalls();
      drawFood();
      drawEchoOrb();
      drawSnake();
    }

    // ----- Kontroller -----
    document.addEventListener("keydown", (e) => {
      if (e.key === "ArrowUp" || e.key === "w" || e.key === "W") {
        changeDirection("up");
      } else if (e.key === "ArrowDown" || e.key === "s" || e.key === "S") {
        changeDirection("down");
      } else if (e.key === "ArrowLeft" || e.key === "a" || e.key === "A") {
        changeDirection("left");
      } else if (e.key === "ArrowRight" || e.key === "d" || e.key === "D") {
        changeDirection("right");
      } else if (e.code === "Space") {
        e.preventDefault();
        handleEcho();
      } else if (e.key === "p" || e.key === "P") {
        togglePause();
      } else if (e.key === "r" || e.key === "R") {
        if (gameOver) {
          startGame();
        }
      }
    });

    // Desktop buttons
    document.getElementById("btn-echo-desktop").addEventListener("click", handleEcho);
    document.getElementById("btn-pause-desktop").addEventListener("click", togglePause);

    // Mobile buttons
    document.getElementById("btn-echo-mobile").addEventListener("click", handleEcho);
    document.getElementById("btn-pause-mobile").addEventListener("click", togglePause);

    document.querySelectorAll(".dpad-btn").forEach((btn) => {
      const dir = btn.dataset.dir;
      const handler = (e) => {
        e.preventDefault();
        changeDirection(dir);
      };
      btn.addEventListener("click", handler);
      btn.addEventListener("touchstart", handler, { passive: false });
    });

    // Basit swipe desteği – isteyen yine kaydırarak oynayabilsin
    let touchStartX = null;
    let touchStartY = null;

    canvas.addEventListener("touchstart", (e) => {
      if (e.touches.length !== 1) return;
      const t = e.touches[0];
      touchStartX = t.clientX;
      touchStartY = t.clientY;
    });

    canvas.addEventListener("touchmove", (e) => {
      if (touchStartX === null || touchStartY === null) return;
      const t = e.touches[0];
      const dx = t.clientX - touchStartX;
      const dy = t.clientY - touchStartY;
      const absX = Math.abs(dx);
      const absY = Math.abs(dy);
      if (Math.max(absX, absY) < 24) return;
      if (absX > absY) {
        changeDirection(dx > 0 ? "right" : "left");
      } else {
        changeDirection(dy > 0 ? "down" : "up");
      }
      touchStartX = null;
      touchStartY = null;
    });

    // Başlat
    resizeCanvas();
    startGame();
  </script>
</body>
</html>
