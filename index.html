<!DOCTYPE html>
<html lang="tr">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Viper's Legacy – Classic+ v2 (Green + Levels)</title>
  <style>
    *{box-sizing:border-box;margin:0;padding:0}
    html,body{height:100%}
    body{
      background:#070a10;
      color:#e6edf3;
      font-family:-apple-system,BlinkMacSystemFont,system-ui,"Segoe UI",Roboto,Arial,sans-serif;
      overflow:hidden;
      touch-action:none;
    }
    #wrap{position:fixed;inset:0}
    canvas{display:block;width:100%;height:100%}

    /* Büyük HUD – sadece menü/pause'da görünür */
    #hud{
      position:absolute;top:12px;left:12px;z-index:50;
      display:flex;gap:10px;flex-wrap:wrap;
      padding:10px 12px;border-radius:14px;
      background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.12);
      backdrop-filter:blur(8px);
      max-width:min(760px,92vw);
    }
    .stat{min-width:68px;text-align:center}
    .k{font-size:11px;opacity:.75;letter-spacing:.6px;text-transform:uppercase}
    .v{font-size:18px;font-weight:950;margin-top:2px}

    #chip{
      position:absolute;top:12px;right:12px;z-index:50;
      padding:10px 12px;border-radius:14px;
      background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.12);
      backdrop-filter:blur(8px);
      text-align:right;
      min-width:180px;
    }
    #chip .name{font-weight:950;font-size:13px;letter-spacing:.5px}
    #chip .desc{font-size:11px;opacity:.82;margin-top:2px}

    /* Küçük HUD – sadece oyunda görünür */
    #mini_hud{
      position:absolute;
      top:10px;
      left:10px;
      z-index:40;
      padding:4px 8px;
      border-radius:999px;
      background:rgba(0,0,0,.6);
      border:1px solid rgba(255,255,255,.14);
      display:flex;
      gap:10px;
      align-items:center;
      font-size:11px;
    }
    .mini-item{
      display:flex;
      gap:3px;
      align-items:baseline;
    }
    .mini-item .label{
      font-size:9px;
      text-transform:uppercase;
      letter-spacing:.14em;
      opacity:.7;
    }
    .mini-item .value{
      font-weight:800;
    }

    #tip{
      position:absolute;top:92px;left:50%;transform:translateX(-50%);
      z-index:60;
      max-width:min(720px,92vw);
      padding:10px 12px;border-radius:14px;
      background:rgba(0,0,0,.55);border:1px solid rgba(255,255,255,.12);
      backdrop-filter:blur(8px);
      font-size:13px;line-height:1.35;
      text-align:center;
      white-space:pre-line;
      opacity:.95;
      pointer-events:none;
      display:none;
    }

    /* Alt kontrol barı: [ECHO] [D-PAD] [DUR] */
    #controls{
      position:absolute;
      bottom:60px;
      left:50%;
      transform:translateX(-50%);
      z-index:55;
      display:flex;
      align-items:flex-end;
      gap:18px;
    }
    .ctrl-col{
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:4px;
    }
    .ctrl-label{
      font-size:11px;
      opacity:.82;
    }

    .btn{
      width:64px;height:64px;border-radius:50%;
      background:rgba(255,255,255,.08);
      border:2px solid rgba(255,255,255,.16);
      color:#e6edf3;
      display:flex;flex-direction:column;align-items:center;justify-content:center;
      user-select:none;
      font-weight:900;
      letter-spacing:.6px;
      font-size:11px;
    }
    .btn .small{font-size:10px;font-weight:800;opacity:.85;margin-top:4px;letter-spacing:.4px}
    .btn.active{background:rgba(100,200,255,.22);border-color:rgba(100,200,255,.75)}
    .btn.cd{background:rgba(255,70,70,.18);border-color:rgba(255,70,70,.55)}

    /* Mobil yön tuş takımı – 3 satır, büyük */
    #dpad{
      display:flex;
      flex-direction:column;
      gap:6px;
    }
    .drow{
      display:flex;
      justify-content:center;
      gap:6px;
    }
    .dspacer{
      width:80px;
      height:80px;
    }
    .dkey{
      width:80px;
      height:80px;
      border-radius:24px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(255,255,255,.06);
      display:flex;
      align-items:center;
      justify-content:center;
      font-size:24px;
      font-weight:900;
      color:#e6edf3;
      user-select:none;
    }
    .dkey:active{
      background:rgba(100,200,255,.28);
      border-color:rgba(100,200,255,.75);
    }

    @media (min-width: 900px){
      #controls{display:none}
    }

    .modal{position:absolute;inset:0;z-index:120;display:flex;align-items:center;justify-content:center;background:rgba(0,0,0,.78)}
    .card{
      width:min(560px,92vw);
      border-radius:18px;
      padding:20px 20px 18px;
      background:rgba(14,18,26,.96);
      border:1px solid rgba(100,200,255,.28);
      box-shadow:0 20px 60px rgba(0,0,0,.55);
      text-align:left;
    }
    .title{
      font-weight:1000;
      font-size:20px;
      letter-spacing:.4px;
      color:#64c8ff;
      margin-bottom:4px
    }
    .subtitle{
      font-size:11px;
      text-transform:uppercase;
      letter-spacing:.18em;
      opacity:.78;
      margin-bottom:10px;
    }
    .section-title{
      font-size:12px;
      font-weight:800;
      text-transform:uppercase;
      letter-spacing:.14em;
      opacity:.9;
      margin:10px 0 4px;
    }
    .section-body{
      font-size:12px;
      line-height:1.55;
      opacity:.92;
    }
    .section-body b{font-weight:800}
    .row{
      display:flex;
      gap:10px;
      justify-content:flex-start;
      flex-wrap:wrap;
      margin-top:14px;
    }
    button.action{
      border:0;cursor:pointer;border-radius:12px;padding:12px 16px;
      font-weight:950;color:#fff;
      background:linear-gradient(135deg,#64c8ff,#3a7bd5);
      font-size:13px;
    }
    button.ghost{background:rgba(255,255,255,.08);border:1px solid rgba(255,255,255,.14)}
    .pill{
      display:inline-flex;gap:8px;align-items:center;
      padding:8px 10px;border-radius:999px;
      border:1px solid rgba(255,255,255,.14);
      background:rgba(255,255,255,.06);
      font-size:12px;opacity:.92;
      margin:8px 6px 0 0;
    }
    .kbd{
      font-weight:950;
      padding:2px 8px;border-radius:8px;
      border:1px solid rgba(255,255,255,.18);
      background:rgba(0,0,0,.35);
    }
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="c"></canvas>

  <!-- Büyük HUD -->
  <div id="hud">
    <div class="stat"><div class="k">skor</div><div class="v" id="ui_score">0</div></div>
    <div class="stat"><div class="k">best</div><div class="v" id="ui_best">0</div></div>
    <div class="stat"><div class="k">can</div><div class="v" id="ui_life">3</div></div>
    <div class="stat"><div class="k">uzunluk</div><div class="v" id="ui_len">5</div></div>
    <div class="stat"><div class="k">hız</div><div class="v" id="ui_spd">x1.0</div></div>
    <div class="stat"><div class="k">echo</div><div class="v" id="ui_echo">3</div></div>
    <div class="stat"><div class="k">bölüm</div><div class="v" id="ui_lvl">1</div></div>
  </div>

  <div id="chip">
    <div class="name" id="ui_mode">CASUAL</div>
    <div class="desc" id="ui_hint">bölüm 1 • klasik</div>
  </div>

  <!-- Küçük HUD -->
  <div id="mini_hud">
    <div class="mini-item"><span class="label">SKR</span><span class="value" id="mini_score">0</span></div>
    <div class="mini-item"><span class="label">CAN</span><span class="value" id="mini_life">3</span></div>
    <div class="mini-item"><span class="label">BLM</span><span class="value" id="mini_level">1</span></div>
  </div>

  <div id="tip"></div>

  <!-- Alt kontrol barı -->
  <div id="controls">
    <div class="ctrl-col">
      <div class="ctrl-label" id="echo_label">echo hak: 3</div>
      <div class="btn" id="btn_echo">
        ECHO
        <div class="small" id="btn_echo_small">hazır</div>
      </div>
    </div>

    <div id="dpad">
      <div class="drow">
        <div class="dspacer"></div>
        <div class="dkey" data-dir="up">▲</div>
        <div class="dspacer"></div>
      </div>
      <div class="drow">
        <div class="dkey" data-dir="left">◀</div>
        <div class="dspacer"></div>
        <div class="dkey" data-dir="right">▶</div>
      </div>
      <div class="drow">
        <div class="dspacer"></div>
        <div class="dkey" data-dir="down">▼</div>
        <div class="dspacer"></div>
      </div>
    </div>

    <div class="ctrl-col">
      <div class="ctrl-label">pause</div>
      <div class="btn" id="btn_pause">
        DUR
        <div class="small">pause</div>
      </div>
    </div>
  </div>

  <!-- Menü -->
  <div class="modal" id="menu">
    <div class="card">
      <div class="title">SnakePlay • Viper's Legacy</div>
      <div class="subtitle">mini oyun • test sürümü</div>

      <div class="section-title">Nasıl oynanır?</div>
      <div class="section-body">
        • Amaç: engellere çarpmadan mümkün olan en yüksek skoru yapmak.<br>
        • Sarı yem: +10 skor ve yılan uzar.<br>
        • Mavi orb: +25 skor ve <b>echo</b> hakkı +1 (maks. 3).<br>
        • Bölüm ilerledikçe parkur ve portal duvarlar zorlaşır.
      </div>

      <div class="section-title">Kontroller</div>
      <div class="section-body">
        Masaüstü:<br>
        • <b>Yön</b>: <span class="kbd">↑↓←→</span> veya <span class="kbd">WASD</span><br>
        • <b>Echo</b>: <span class="kbd">Space</span><br>
        • <b>Duraklat</b>: <span class="kbd">P</span><br><br>
        Mobil:<br>
        • Ekranı kaydırarak <b>veya</b> alttaki yön tuşlarını kullanarak oynayabilirsin.<br>
        • Ekrana çift dokunma: <b>echo</b> (geri sarma).
      </div>

      <div class="pill">
        <span class="kbd">Local Best</span>
        skorların şu an sadece bu cihazda tutulur – mini app lider tahtası daha sonra eklenecek
      </div>

      <div class="row">
        <button class="action" id="btn_casual">Casual (3 can)</button>
        <button class="action ghost" id="btn_classic">Classic (1 can)</button>
        <button class="action ghost" id="btn_how">Kısa ipucu</button>
      </div>
    </div>
  </div>

  <!-- Game Over -->
  <div class="modal" id="over" style="display:none">
    <div class="card">
      <div class="title">Oyun bitti</div>
      <div class="subtitle">tur özeti</div>
      <div class="section-body" id="over_txt"></div>
      <div class="row">
        <button class="action" id="btn_retry">Tekrar oyna</button>
        <button class="action ghost" id="btn_share">Skoru paylaş</button>
      </div>
    </div>
  </div>
</div>

<script>
(() => {
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const ui = {
    score: document.getElementById('ui_score'),
    best: document.getElementById('ui_best'),
    life: document.getElementById('ui_life'),
    len: document.getElementById('ui_len'),
    spd: document.getElementById('ui_spd'),
    echo: document.getElementById('ui_echo'),
    lvl: document.getElementById('ui_lvl'),
    mode: document.getElementById('ui_mode'),
    hint: document.getElementById('ui_hint'),
  };

  const miniScore = document.getElementById('mini_score');
  const miniLife  = document.getElementById('mini_life');
  const miniLevel = document.getElementById('mini_level');
  const miniHud   = document.getElementById('mini_hud');

  const echoLabel = document.getElementById('echo_label');

  const tipEl = document.getElementById('tip');
  const menuEl = document.getElementById('menu');
  const overEl = document.getElementById('over');
  const overTxt = document.getElementById('over_txt');
  const btnEcho = document.getElementById('btn_echo');
  const btnEchoSmall = document.getElementById('btn_echo_small');
  const btnPause = document.getElementById('btn_pause');
  const dpadKeys = document.querySelectorAll('.dkey');

  const hudEl  = document.getElementById('hud');
  const chipEl = document.getElementById('chip');

  const BEST_KEY = 'viper_classic_best_v2_green_levels';

  const SNAKE_RGB = { r: 46, g: 204, b: 113 };
  const WALL_COLOR = 'rgba(46, 204, 113, .35)';
  const WALL_PORTAL_COLOR = 'rgba(100, 200, 255, .35)';
  const OBST_COLOR = 'rgba(255, 255, 255, .10)';

  let W=0,H=0,DPR=1;
  let CELL=20, COLS=30, ROWS=18, OFFX=0, OFFY=0;

  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const eq=(a,b)=>a.x===b.x && a.y===b.y;
  const randInt=(a,b)=>Math.floor(a + Math.random()*(b-a+1));
  const key=(x,y)=>x+'|'+y;
  const toPx=(cell)=>({ x: OFFX + cell.x*CELL + CELL/2, y: OFFY + cell.y*CELL + CELL/2 });

  let state = 'menu';
  let mode  = 'casual';

  let score = 0;
  let lives = 3;

  let level = 1;
  let nextLevelAt = 80;
  let portalMode = 'none';
  let obstacles = new Set();

  let snake = [];
  let dir = {x:1,y:0};
  let nextDir = {x:1,y:0};
  let grow = 0;

  let baseMps = 6.0;
  let mps = 6.0;

  let food = null;
  let orb  = null;
  let orbTimer = 0;

  let echoCharges = 3;
  const echoMax = 3;
  const echoCd  = 1.2;
  let echoCdLeft = 0;

  const history = [];
  const HISTORY_MAX = 210;

  let iFrames = 0;
  let acc = 0;
  let echoPulse = 0;
  let tipUntil = 0;

  function pulseEcho(){ echoPulse = 1.0; }

  function refreshHudVisibility(){
    if (state === 'run'){
      hudEl.style.display = 'none';
      chipEl.style.display = 'none';
      miniHud.style.display = 'flex';
    } else if (state === 'menu' || state === 'pause'){
      hudEl.style.display = 'flex';
      chipEl.style.display = 'block';
      miniHud.style.display = 'none';
    } else {
      hudEl.style.display = 'none';
      chipEl.style.display = 'none';
      miniHud.style.display = 'none';
    }
  }

  function resize(){
    DPR = window.devicePixelRatio || 1;
    const r = canvas.getBoundingClientRect();
    W = Math.floor(r.width);
    H = Math.floor(r.height);
    canvas.width = Math.floor(W * DPR);
    canvas.height = Math.floor(H * DPR);
    ctx.setTransform(DPR,0,0,DPR,0,0);

    const sidePad = 28;
    const topPad = 60;   // ÖNCEKİNDEN BİRAZ DAHA YUKARIDA
    const bottomPad = 340; // SAHAYI YUKARI ÇEKMEK İÇİN ARTTIRILDI

    const availW = Math.max(200, W - sidePad*2);
    const availH = Math.max(200, H - topPad - bottomPad);

    const baseCell = (availW < 480) ? 16 : 20;
    CELL = baseCell;

    COLS = Math.max(10, Math.floor(availW / CELL));
    const maxBoardH = Math.min(availH, availW * 1.4);
    ROWS = Math.max(10, Math.floor(maxBoardH / CELL));

    const boardW = COLS * CELL;
    const boardH = ROWS * CELL;

    OFFX = Math.floor((W - boardW)/2);
    OFFY = topPad + Math.floor((availH - boardH)*0.05);

    if (state !== 'menu'){
      snake.forEach(s => { s.x = clamp(s.x, 0, COLS-1); s.y = clamp(s.y, 0, ROWS-1); });
      if (food) { food.x = clamp(food.x, 0, COLS-1); food.y = clamp(food.y, 0, ROWS-1); }
      if (orb)  { orb.x  = clamp(orb.x,  0, COLS-1);  orb.y  = clamp(orb.y,  ROWS-1); }
      rebuildObstaclesForLevel();
    }
  }

  function showTip(text, seconds){
    tipEl.textContent = text;
    tipEl.style.display = 'block';
    tipUntil = performance.now() + (seconds||2.0)*1000;
  }
  function tickTip(){
    if (tipEl.style.display === 'none') return;
    if (performance.now() > tipUntil) tipEl.style.display = 'none';
  }

  function bestGet(){ return parseInt(localStorage.getItem(BEST_KEY) || '0', 10); }
  function bestSet(v){ localStorage.setItem(BEST_KEY, String(v)); }

  function levelTheme(){
    if (level === 1) return 'klasik';
    if (level === 2) return 'parkur duvarlar';
    if (level === 3) return 'portal duvarlar (sağ-sol)';
    if (level === 4) return 'portal duvarlar (tam)';
    return portalMode === 'all' ? 'labirent' : 'zorlu';
  }

  function applyLevelRules(){
    if (level === 1) portalMode = 'none';
    else if (level === 2) portalMode = 'none';
    else if (level === 3) portalMode = 'h';
    else portalMode = 'all';

    rebuildObstaclesForLevel();
    showTip(`bölüm ${level}\n${levelTheme()}`, 1.2);
  }

  function rebuildObstaclesForLevel(){
    obstacles.clear();
    if (level <= 1) return;

    const rects = Math.min(8, 2 + Math.floor(level/2));
    const margin = 2;
    const cx = Math.floor(COLS/2), cy = Math.floor(ROWS/2);

    const inCenterSafe = (x,y)=> (Math.abs(x-cx) <= 4 && Math.abs(y-cy) <= 3);

    for (let r=0;r<rects;r++){
      const w = randInt(3, Math.min(10, Math.max(3, Math.floor(COLS*0.24))));
      const h = randInt(2, Math.min(8,  Math.max(2, Math.floor(ROWS*0.22))));
      const x0 = randInt(margin, Math.max(margin, COLS - margin - w));
      const y0 = randInt(margin, Math.max(margin, ROWS - margin - h));

      let ok = true;
      for (let y=y0;y<y0+h;y++){
        for (let x=x0;x<x0+w;x++){
          if (inCenterSafe(x,y)) { ok=false; break; }
        }
        if (!ok) break;
      }
      if (!ok) continue;

      for (let y=y0;y<y0+h;y++) for (let x=x0;x<x0+w;x++) obstacles.add(key(x,y));
    }

    const holes = Math.min(18, 6 + level*2);
    for (let i=0;i<holes;i++) obstacles.delete(key(randInt(0,COLS-1), randInt(0,ROWS-1)));

    snake.forEach(s => obstacles.delete(key(s.x,s.y)));
    if (food) obstacles.delete(key(food.x, food.y));
    if (orb) obstacles.delete(key(orb.x, orb.y));
  }

  function spawnEmptyCell(){
    for (let t=0;t<650;t++){
      const c = {x: randInt(0,COLS-1), y: randInt(0,ROWS-1)};
      if (snake.some(s=>eq(s,c))) continue;
      if (food && eq(food,c)) continue;
      if (orb && eq(orb,c)) continue;
      if (obstacles.has(key(c.x,c.y))) continue;
      return c;
    }
    for (let y=0;y<ROWS;y++) for (let x=0;x<COLS;x++){
      const c={x,y};
      if (snake.some(s=>eq(s,c))) continue;
      if (food && eq(food,c)) continue;
      if (orb && eq(orb,c)) continue;
      if (obstacles.has(key(x,y))) continue;
      return c;
    }
    return {x:0,y:0};
  }

  function updateUI(){
    ui.score.textContent = score;
    const b = Math.max(bestGet(), score);
    ui.best.textContent = b;
    ui.life.textContent = lives;
    ui.len.textContent = snake.length;
    ui.spd.textContent = 'x' + (mps/6.0).toFixed(1);
    ui.echo.textContent = echoCharges;
    ui.lvl.textContent = level;

    miniScore.textContent = score;
    miniLife.textContent  = lives;
    miniLevel.textContent = level;

    echoLabel.textContent = `echo hak: ${echoCharges}`;

    ui.mode.textContent = (mode==='classic') ? 'CLASSIC' : 'CASUAL';
    let extra = `bölüm ${level} • ${levelTheme()}`;
    if (portalMode === 'h')   extra += ' • portal: sağ-sol';
    if (portalMode === 'all') extra += ' • portal: tüm kenarlar';
    ui.hint.textContent = extra;
  }

  function setDir(nx,ny){
    if (nx === -dir.x && ny === -dir.y) return;
    nextDir = {x:nx,y:ny};
  }

  function pushHistory(){
    history.push({
      snake: snake.map(s=>({x:s.x,y:s.y})),
      dir: {x:dir.x,y:dir.y},
      nextDir: {x:nextDir.x,y:nextDir.y},
      grow,
      score,
      lives,
      baseMps,
      mps,
      echoCharges,
      food: food ? {x:food.x,y:food.y} : null,
      orb: orb ? {x:orb.x,y:orb.y,ttl:orb.ttl} : null,
      orbTimer,
      iFrames,
      level, nextLevelAt, portalMode,
    });
    if (history.length > HISTORY_MAX) history.shift();
  }

  function rewindSnapshot(steps){
    if (history.length < steps+2) return null;
    const idx = Math.max(0, history.length - 1 - steps);
    return history[idx];
  }

  function doEcho(){
    if (state !== 'run') return;
    if (echoCharges <= 0) return;
    if (echoCdLeft > 0) return;

    const snap = rewindSnapshot(10);
    if (!snap) return;

    echoCharges -= 1;
    echoCdLeft = echoCd;

    snake = snap.snake.map(s=>({x:s.x,y:s.y}));
    dir = {x:snap.dir.x,y:snap.dir.y};
    nextDir = {x:snap.nextDir.x,y:snap.nextDir.y};
    grow = snap.grow;

    score = snap.score;
    lives = snap.lives;
    baseMps = snap.baseMps;
    mps = snap.mps;

    level = snap.level;
    nextLevelAt = snap.nextLevelAt;
    portalMode = snap.portalMode;

    food = snap.food ? {x:snap.food.x,y:snap.food.y} : spawnEmptyCell();
    orb = snap.orb ? {x:snap.orb.x,y:snap.orb.y,ttl:snap.orb.ttl} : null;
    orbTimer = snap.orbTimer;

    iFrames = Math.max(snap.iFrames, 0.7);

    rebuildObstaclesForLevel();
    if (food && obstacles.has(key(food.x, food.y))) food = spawnEmptyCell();
    if (orb && obstacles.has(key(orb.x, orb.y)))   orb = spawnEmptyCell();

    pulseEcho();
    showTip('echo\ngeri sardın', 0.8);
    updateUI();
  }

  function maybeLevelUp(){
    if (score < nextLevelAt) return;
    level += 1;
    nextLevelAt += 80 + Math.min(160, level*22);
    applyLevelRules();
  }

  function spawnOrbMaybe(){
    orbTimer += 1;
    if (orb) return;
    const chance = (score < 200) ? 0.12 : 0.18;
    if (Math.random() < chance){
      orb = spawnEmptyCell();
      orb.ttl = 110;
    }
  }

  function eatFood(){
    score += 10;
    grow += 1;

    baseMps = 6.0 + Math.min(8.0, (score/160));
    mps = baseMps;

    food = spawnEmptyCell();
    spawnOrbMaybe();

    const best = bestGet();
    if (score > best) bestSet(score);

    maybeLevelUp();
  }

  function eatOrb(){
    if (!orb) return;
    score += 25;
    echoCharges = Math.min(echoMax, echoCharges + 1);
    orb = null;

    const best = bestGet();
    if (score > best) bestSet(score);

    maybeLevelUp();
  }

  function gameOver(reason){
    state = 'over';
    refreshHudVisibility();
    overEl.style.display = 'flex';
    const best = Math.max(bestGet(), score);
    bestSet(best);

    const payload = {
      reason,
      score,
      best,
      length: snake.length,
      level,
      mode,
      timestamp: Date.now()
    };

    overTxt.textContent =
      `Sebep: ${reason}\n` +
      `Skor: ${score}\n` +
      `Uzunluk: ${snake.length}\n` +
      `Bölüm: ${level}\n` +
      `Best: ${best}`;

    window.SNAKE_RESULT = payload;
    try{ console.log('[SnakePlay] result', payload); }catch(_){}
  }

  function onCrash(reason){
    if (iFrames > 0) return;

    if (mode === 'classic'){
      gameOver(reason);
      return;
    }

    lives -= 1;
    if (lives <= 0){
      gameOver(reason);
      return;
    }

    const cx = Math.floor(COLS/2);
    const cy = Math.floor(ROWS/2);

    const maxLen = Math.max(3, COLS - 4);
    const keepLen = Math.min(Math.max(5, snake.length), maxLen);

    snake = [];
    const startX = Math.max(1, Math.min(COLS - keepLen - 1, cx - Math.floor(keepLen/2)));
    for (let i=0;i<keepLen;i++) snake.push({x: startX + i, y: cy});

    dir = {x:1,y:0};
    nextDir = {x:1,y:0};
    grow = 0;

    iFrames = 1.2;

    rebuildObstaclesForLevel();
    if (food && snake.some(s=>eq(s,food))) food = spawnEmptyCell();
    if (orb && snake.some(s=>eq(s,orb)))   orb = spawnEmptyCell();

    history.length = 0;
    pushHistory();

    showTip('çarpışma\n1 can gitti', 1.0);
    updateUI();
  }

  function resetRun(){
    score = 0;
    lives = (mode === 'classic') ? 1 : 3;

    level = 1;
    nextLevelAt = 80;
    portalMode = 'none';

    echoCharges = (mode === 'classic') ? 2 : 3;
    echoCdLeft = 0;
    iFrames = 0;

    baseMps = 6.0;
    mps = baseMps;

    const cx = Math.floor(COLS/2);
    const cy = Math.floor(ROWS/2);

    snake = [];
    for (let i=0;i<5;i++) snake.push({x: cx - i, y: cy});

    dir = {x:1,y:0};
    nextDir = {x:1,y:0};
    grow = 0;

    acc = 0;

    food = null;
    orb = null;
    orbTimer = 0;

    rebuildObstaclesForLevel();
    food = spawnEmptyCell();

    history.length = 0;
    pushHistory();

    updateUI();
    showTip('ipucu\nspace = echo (geri sar)\nmavi orb = echo +1\nbölüm atladıkça parkur + portal gelir', 3.2);
  }

  function start(modeName){
    mode = modeName;
    state = 'run';
    refreshHudVisibility();
    menuEl.style.display = 'none';
    overEl.style.display = 'none';
    resetRun();
  }

  function togglePause(){
    if (state === 'run'){
      state = 'pause';
      refreshHudVisibility();
      btnPause.classList.add('active');
      showTip('duraklatıldı\nP veya DUR', 999);
    } else if (state === 'pause'){
      state = 'run';
      refreshHudVisibility();
      btnPause.classList.remove('active');
      tipEl.style.display = 'none';
    }
  }

  function step(){
    dir = nextDir;

    const head = snake[0];
    let nx = head.x + dir.x;
    let ny = head.y + dir.y;

    if (nx < 0 || nx >= COLS || ny < 0 || ny >= ROWS){
      if (portalMode === 'all'){
        if (nx < 0) nx = COLS-1; else if (nx >= COLS) nx = 0;
        if (ny < 0) ny = ROWS-1; else if (ny >= ROWS) ny = 0;
      } else if (portalMode === 'h'){
        if (nx < 0) nx = COLS-1; else if (nx >= COLS) nx = 0;
        else { onCrash('duvar'); return; }
        if (ny < 0 || ny >= ROWS){ onCrash('duvar'); return; }
      } else {
        onCrash('duvar');
        return;
      }
    }

    const nh = {x:nx,y:ny};

    if (obstacles.has(key(nh.x, nh.y))){ onCrash('engel'); return; }

    const tail = snake[snake.length-1];
    const hitsSelf = snake.some((s,idx)=>{
      if (idx === snake.length-1 && grow === 0 && eq(tail, nh)) return false;
      return eq(s, nh);
    });
    if (hitsSelf){ onCrash('kendin'); return; }

    snake.unshift(nh);

    if (food && eq(nh, food)){
      eatFood();
    } else if (orb && eq(nh, orb)){
      eatOrb();
    } else {
      if (grow > 0) grow -= 1;
      else snake.pop();
    }

    if (orb){
      orb.ttl -= 1;
      if (orb.ttl <= 0) orb = null;
    }

    pushHistory();
  }

  function drawWalls(){
    ctx.lineWidth = 4;
    ctx.strokeStyle = (portalMode === 'none') ? WALL_COLOR : WALL_PORTAL_COLOR;
    ctx.strokeRect(OFFX+2, OFFY+2, COLS*CELL-4, ROWS*CELL-4);
  }

  function drawObstacles(){
    if (!obstacles.size) return;
    ctx.fillStyle = OBST_COLOR;
    for (const k of obstacles){
      const [xs, ys] = k.split('|');
      const x = parseInt(xs,10), y = parseInt(ys,10);
      const px = OFFX + x*CELL;
      const py = OFFY + y*CELL;
      ctx.fillRect(px, py, CELL, CELL);
    }
    ctx.strokeStyle = 'rgba(255,255,255,.08)';
    ctx.lineWidth = 1;
    for (const k of obstacles){
      const [xs, ys] = k.split('|');
      const x = parseInt(xs,10), y = parseInt(ys,10);
      const px = OFFX + x*CELL;
      const py = OFFY + y*CELL;
      ctx.strokeRect(px+0.5, py+0.5, CELL-1, CELL-1);
    }
  }

  function draw(){
    ctx.fillStyle = '#070a10';
    ctx.fillRect(0,0,W,H);

    const g = ctx.createRadialGradient(W/2,H/2, Math.min(W,H)*0.1, W/2,H/2, Math.min(W,H)*0.75);
    g.addColorStop(0, 'rgba(0,0,0,0)');
    g.addColorStop(1, 'rgba(0,0,0,.35)');
    ctx.fillStyle = g;
    ctx.fillRect(0,0,W,H);

    ctx.strokeStyle = 'rgba(255,255,255,.05)';
    ctx.lineWidth = 1;
    for (let x=0;x<=COLS;x++){
      const px = OFFX + x*CELL;
      ctx.beginPath(); ctx.moveTo(px, OFFY); ctx.lineTo(px, OFFY + ROWS*CELL); ctx.stroke();
    }
    for (let y=0;y<=ROWS;y++){
      const py = OFFY + y*CELL;
      ctx.beginPath(); ctx.moveTo(OFFX, py); ctx.lineTo(OFFX + COLS*CELL, py); ctx.stroke();
    }

    drawWalls();
    drawObstacles();

    if (echoPulse > 0 && snake.length){
      const p = toPx(snake[0]);
      const r = (CELL*2.2) * (1.2 - echoPulse);
      ctx.beginPath();
      ctx.arc(p.x,p.y,r,0,Math.PI*2);
      ctx.strokeStyle = `rgba(100,200,255,${0.22*echoPulse})`;
      ctx.lineWidth = 3;
      ctx.stroke();
      echoPulse = Math.max(0, echoPulse - 0.06);
    }

    if (food){
      const p = toPx(food);
      ctx.beginPath();
      ctx.arc(p.x,p.y, CELL*0.34, 0, Math.PI*2);
      ctx.fillStyle = '#ffd166';
      ctx.fill();

      ctx.beginPath();
      ctx.arc(p.x,p.y, CELL*0.62, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(255,209,102,.22)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    if (orb){
      const p = toPx(orb);
      ctx.beginPath();
      ctx.arc(p.x,p.y, CELL*0.34, 0, Math.PI*2);
      ctx.fillStyle = '#64c8ff';
      ctx.fill();

      ctx.beginPath();
      ctx.arc(p.x,p.y, CELL*0.78, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(100,200,255,.25)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    for (let i=snake.length-1;i>=0;i--){
      const s = snake[i];
      const p = toPx(s);
      const t = i / Math.max(1, snake.length-1);
      const r = CELL * (0.40 - 0.12*t);
      const alpha = (i===0) ? 1 : (0.90 - 0.55*t);

      const col = `rgba(${SNAKE_RGB.r},${SNAKE_RGB.g},${SNAKE_RGB.b},${alpha})`;
      ctx.beginPath();
      ctx.arc(p.x,p.y,r,0,Math.PI*2);
      ctx.fillStyle = col;
      ctx.fill();

      ctx.beginPath();
      ctx.arc(p.x,p.y,r+2,0,Math.PI*2);
      ctx.strokeStyle = `rgba(255,255,255,${0.14 - 0.10*t})`;
      ctx.lineWidth = 1;
      ctx.stroke();
    }

    if (snake.length){
      const p = toPx(snake[0]);
      const rr = CELL*0.44;
      const ax = dir.x, ay = dir.y;
      const lx = p.x + ax*rr*0.30;
      const ly = p.y + ay*rr*0.30;
      const ox = (ay!==0) ? rr*0.22 : 0;
      const oy = (ax!==0) ? rr*0.22 : 0;

      ctx.beginPath();
      ctx.arc(lx + ox, ly - oy, rr*0.22, 0, Math.PI*2);
      ctx.arc(lx - ox, ly + oy, rr*0.22, 0, Math.PI*2);
      ctx.fillStyle = 'rgba(255,255,255,.95)';
      ctx.fill();

      ctx.beginPath();
      ctx.arc(lx + ox + ax*rr*0.08, ly - oy + ay*rr*0.08, rr*0.11, 0, Math.PI*2);
      ctx.arc(lx - ox + ax*rr*0.08, ly + oy + ay*rr*0.08, rr*0.11, 0, Math.PI*2);
      ctx.fillStyle = '#070a10';
      ctx.fill();
    }

    if (iFrames > 0 && snake.length){
      const p = toPx(snake[0]);
      ctx.beginPath();
      ctx.arc(p.x,p.y, CELL*0.95, 0, Math.PI*2);
      ctx.strokeStyle = 'rgba(255,255,255,.22)';
      ctx.lineWidth = 2;
      ctx.stroke();
    }

    if (state === 'pause'){
      ctx.fillStyle = 'rgba(0,0,0,.35)';
      ctx.fillRect(0,0,W,H);
      ctx.fillStyle = 'rgba(255,255,255,.92)';
      ctx.font = '900 28px system-ui, -apple-system, Segoe UI, Roboto, Arial';
      ctx.textAlign = 'center';
      ctx.fillText('PAUSE', W/2, H/2);
    }
  }

  let last = 0;
  function loop(ts){
    if (!last) last = ts;
    const dt = Math.min(0.05, (ts - last)/1000);
    last = ts;

    tickTip();

    if (state === 'run'){
      if (echoCdLeft > 0) echoCdLeft = Math.max(0, echoCdLeft - dt);
      if (iFrames > 0)   iFrames   = Math.max(0, iFrames   - dt);

      mps = baseMps + Math.min(2.7, (snake.length-5)*0.06) + Math.min(2.0, (level-1)*0.12);
      const stepInterval = 1 / mps;
      acc += dt;

      while (acc >= stepInterval){
        acc -= stepInterval;
        step();
        if (state !== 'run') break;
      }

      if (echoCdLeft > 0){
        btnEcho.classList.remove('active');
        btnEcho.classList.add('cd');
        btnEchoSmall.textContent = Math.ceil(echoCdLeft) + 's';
      } else if (echoCharges <= 0){
        btnEcho.classList.remove('active');
        btnEcho.classList.add('cd');
        btnEchoSmall.textContent = '0';
      } else {
        btnEcho.classList.remove('cd');
        btnEcho.classList.add('active');
        btnEchoSmall.textContent = 'hazır';
      }

      updateUI();
    }

    draw();
    requestAnimationFrame(loop);
  }

  window.addEventListener('keydown', (e) => {
    if (state === 'menu') return;

    if (e.code === 'ArrowUp' || e.code === 'KeyW'){ setDir(0,-1); e.preventDefault(); }
    else if (e.code === 'ArrowDown' || e.code === 'KeyS'){ setDir(0, 1); e.preventDefault(); }
    else if (e.code === 'ArrowLeft' || e.code === 'KeyA'){ setDir(-1,0); e.preventDefault(); }
    else if (e.code === 'ArrowRight' || e.code === 'KeyD'){ setDir( 1,0); e.preventDefault(); }
    else if (e.code === 'Space'){ doEcho(); e.preventDefault(); }
    else if (e.code === 'KeyP'){ togglePause(); e.preventDefault(); }
    else if (e.code === 'Escape'){ if (state==='run'||state==='pause') togglePause(); }
  });

  // Mobil swipe + double tap
  let touchStart = null;
  let lastTap = 0;

  canvas.addEventListener('touchstart', (e) => {
    e.preventDefault();
    if (state === 'menu') return;
    const t = e.touches[0];
    touchStart = {x:t.clientX, y:t.clientY};

    const now = performance.now();
    if (now - lastTap < 260){
      doEcho();
      lastTap = 0;
    } else {
      lastTap = now;
    }
  }, {passive:false});

  canvas.addEventListener('touchmove', (e) => {
    e.preventDefault();
    if (state === 'menu') return;
    if (!touchStart) return;
    const t = e.touches[0];
    const dx = t.clientX - touchStart.x;
    const dy = t.clientY - touchStart.y;
    const adx = Math.abs(dx), ady = Math.abs(dy);
    if (Math.max(adx,ady) < 18) return;

    if (adx > ady) setDir(dx > 0 ? 1 : -1, 0);
    else setDir(0, dy > 0 ? 1 : -1);

    touchStart = null;
  }, {passive:false});

  canvas.addEventListener('touchend', () => { touchStart = null; }, {passive:false});

  // Mobil yön tuş takımı
  dpadKeys.forEach(btn => {
    const dirName = btn.dataset.dir;
    btn.addEventListener('pointerdown', (e) => {
      e.preventDefault();
      if (state === 'menu') return;
      if (dirName === 'up') setDir(0,-1);
      else if (dirName === 'down') setDir(0,1);
      else if (dirName === 'left') setDir(-1,0);
      else if (dirName === 'right') setDir(1,0);
    });
  });

  btnEcho.addEventListener('click', () => doEcho());
  btnPause.addEventListener('click', () => togglePause());

  document.getElementById('btn_casual').addEventListener('click', () => start('casual'));
  document.getElementById('btn_classic').addEventListener('click', () => start('classic'));
  document.getElementById('btn_how').addEventListener('click', () => showTip('kısa ipucu\n1 sarı yem büyütür\n2 mavi orb echo +1\n3 bölüm atlayınca parkur/portal gelir\n4 space = geri sar', 4.2));

  document.getElementById('btn_retry').addEventListener('click', () => {
    overEl.style.display = 'none';
    start(mode);
  });

  document.getElementById('btn_share').addEventListener('click', async () => {
    const txt = `Viper's Legacy Classic+ skorum ${score} bölüm ${level} uzunluk ${snake.length}`;
    try{
      if (navigator.share) await navigator.share({text:txt});
      else {
        await navigator.clipboard.writeText(txt);
        alert('kopyalandı');
      }
    }catch(_){ }
  });

  function init(){
    ui.best.textContent = bestGet();
    resize();
    resetRun();
    state = 'menu';
    refreshHudVisibility();
    menuEl.style.display = 'flex';
    requestAnimationFrame(loop);
  }

  window.addEventListener('resize', resize);
  window.addEventListener('load', init);
})();
</script>
</body>
</html>
